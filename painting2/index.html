<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('arc-formation', {
        init: function () {
          this.particles = [];
          this.time = 0;
          const el = this.el;
          const count = 600;

          // Cercle: centre et rayon
          this.cx = 0.18;
          this.cy = 0.22;

          // Timings du cycle (en secondes)
          this.buildDuration  = 5.0;  // temps pour construire l'arc
          this.holdDuration   = 2.0;  // temps où l'arc est complet
          this.fadeDuration   = 3.0;  // temps pour se dissoudre
          this.pauseDuration  = 1.0;  // pause avant de recommencer
          this.cycleDuration  = this.buildDuration + this.holdDuration
                              + this.fadeDuration + this.pauseDuration;

          // Arc MANQUANT: la partie du cercle hors de la photo
          // L'arc visible dans la photo va de ~120° à ~300°
          // La partie manquante va de ~300° à ~480° (=120°) en passant par le haut
          this.arcStart = Math.PI * 1.65;  // ~300°
          this.arcEnd   = Math.PI * 2.65;  // ~480° = complète le cercle

          const arcLength = this.arcEnd - this.arcStart;

          // Palette: bleu-noir du pigment laque
          const blues = ['#0d2a45', '#1a3a5c', '#2a5a8c', '#163854', '#0a1f33', '#c8dff0', '#7aadd4'];

          for (let i = 0; i < count; i++) {
            const dot = document.createElement('a-sphere');

            // Position fixe le long de l'arc manquant
            const t = i / count;  // 0 = début de l'arc, 1 = fin
            const angle = this.arcStart + t * arcLength;

            // Rayon légèrement irrégulier — texture naturelle
            const radialJitter = (Math.random() - 0.5) * 0.055;
            const r = 0.30 + radialJitter;

            const x = this.cx + r * Math.cos(angle);
            const y = this.cy + r * Math.sin(angle);

            // Légère variation en Z — certaines particules flottent plus
            const zOffset = 0.01 + Math.random() * 0.06;

            const radius = 0.003 + Math.random() * 0.006;

            // Couleur: plus foncé près des extrémités, plus clair au milieu
            const midness = Math.sin(t * Math.PI);
            const colorIndex = Math.floor(midness * 4 + Math.random() * 2);
            const color = blues[Math.min(colorIndex, blues.length - 1)];

            dot.setAttribute('radius', radius);
            dot.setAttribute('color', color);
            dot.setAttribute('material', 'transparent: true; opacity: 0; shader: flat');
            dot.setAttribute('position', `${x} ${y} ${zOffset}`);
            el.appendChild(dot);

            this.particles.push({
              el: dot,
              t,           // position normalisée 0→1 le long de l'arc
              x, y, zOffset,
              ready: false
            });
          }
        },

        tick: function(t, dt) {
          this.time += dt * 0.001;

          // Position dans le cycle
          const cycleT = this.time % this.cycleDuration;

          const buildEnd  = this.buildDuration;
          const holdEnd   = buildEnd + this.holdDuration;
          const fadeEnd   = holdEnd + this.fadeDuration;

          this.particles.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.ready = true;
            }

            let opacity = 0;

            if (cycleT < buildEnd) {
              // PHASE BUILD: le front avance le long de l'arc
              // La particule à t=0 apparaît en premier, t=1 en dernier
              const buildFront = cycleT / buildEnd; // 0→1
              if (p.t <= buildFront) {
                // Fondu d'apparition sur une petite fenêtre derrière le front
                const fadeIn = Math.min((buildFront - p.t) / 0.08, 1.0);
                opacity = fadeIn * 0.88;
              }

            } else if (cycleT < holdEnd) {
              // PHASE HOLD: tout visible
              opacity = 0.88;

            } else if (cycleT < fadeEnd) {
              // PHASE DISSOLVE: disparaît dans l'ordre inverse
              const dissolveFront = (cycleT - holdEnd) / this.fadeDuration; // 0→1
              const dissolvePos = 1 - p.t; // t=1 disparaît en premier
              if (dissolvePos <= dissolveFront) {
                const fadeOut = Math.min((dissolveFront - dissolvePos) / 0.08, 1.0);
                opacity = (1 - fadeOut) * 0.88;
              } else {
                opacity = 0.88;
              }

            }
            // PHASE PAUSE: opacity reste 0

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) mesh.material.opacity = opacity;
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity arc-formation></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
    </a-scene>
  </body>
</html>
