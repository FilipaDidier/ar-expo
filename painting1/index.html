<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('ink-comet', {
        init: function () {
          this.particles = [];
          const el = this.el;
          const count = 800;
          const blues = ['#0d2a45', '#1a3a5c', '#2a5a8c', '#4a7fa5', '#163854', '#0a1f33'];

          // RED mark: upper right dense blue blob
          this.exitX  =  0.12;
          this.exitY  =  0.22;

          // GREEN mark: left middle blue zone
          this.enterX = -0.22;
          this.enterY =  0.08;

          // Depth toward viewer at peak
          this.maxZ = 1.2;

          // Comet occupies 38% of the loop
          // Front arc = 50% of loop
          // So head and tail are NEVER both at painting surface simultaneously
          this.streamLength = 0.38;

          for (let i = 0; i < count; i++) {
            const dot = document.createElement('a-sphere');

            // Smaller particles
            const radius = 0.0015 + Math.random() * 0.0025;
            const color  = blues[Math.floor(Math.random() * blues.length)];

            const baseT = (i / count) * this.streamLength;
            const n = baseT / this.streamLength; // 0=head, 1=tail

            // Jitter: FIXED, calculated once, never changes — eliminates trembling
            // Wider in middle of stream, tighter at head and tail
            const envelope = Math.sin(n * Math.PI);
            const spread = 0.015 + envelope * 0.055;
            const jitterX = (Math.random() - 0.5) * spread;
            const jitterY = (Math.random() - 0.5) * spread * 0.5;

            dot.setAttribute('radius', radius);
            dot.setAttribute('color', color);
            dot.setAttribute('material', 'transparent: true; opacity: 0; shader: flat');
            el.appendChild(dot);

            this.particles.push({
              el: dot,
              loopT: baseT + 0.05,
              baseN: n,
              jitterX,
              jitterY,
              ready: false
            });
          }
        },

        getPos: function(loopT) {
          const t = loopT % 1.0;

          // Front arc: 0 → 0.5 (visible)
          // Back arc: 0.5 → 1.0 (hidden behind painting)
          if (t > 0.5) return null;

          const n = t / 0.5; // 0→1 across front arc

          // X: exit → enter with a LARGE bow downward-right at peak
          // Large bowX makes the arc round instead of oval
          const x = this.exitX + (this.enterX - this.exitX) * n
                  + 0.35 * Math.sin(n * Math.PI); // large bow = rounder

          // Y: exit → enter with downward arc (falling/gravity feel)
          const y = this.exitY + (this.enterY - this.exitY) * n
                  - 0.28 * Math.sin(n * Math.PI); // large downward bow

          // Z: deep sine, zero at painting endpoints, peaks at center
          const z = this.maxZ * Math.sin(n * Math.PI);

          return { x, y, z, n };
        },

        tick: function (t, dt) {
          const advance = (dt * 0.001) / 7.0;

          this.particles.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.ready = true;
            }

            p.loopT += advance;
            if (p.loopT >= 1.0) p.loopT -= 1.0;

            const pos = this.getPos(p.loopT);

            if (!pos) {
              p.el.object3D.position.set(0, 0, -2);
              const mesh = p.el.getObject3D('mesh');
              if (mesh && mesh.material) mesh.material.opacity = 0;
              return;
            }

            p.el.object3D.position.set(
              pos.x + p.jitterX,
              pos.y + p.jitterY,
              pos.z
            );

            // Opacity: fades only near z=0 (painting surface)
            // Stays fully bright throughout all of space
            const zFade = Math.min(pos.z / 0.08, 1.0);

            // Comet dimming: head (baseN=0) bright, tail (baseN=1) dimmer
            const cometDim = 1 - Math.pow(p.baseN, 0.6) * 0.55;

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) {
              mesh.material.opacity = zFade * cometDim * 0.90;
            }
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity ink-comet></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
