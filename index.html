<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('ink-comet', {
        init: function () {
          this.particles = [];
          const el = this.el;
          const count = 800;
          const blues = ['#0d2a45', '#1a3a5c', '#2a5a8c', '#4a7fa5', '#163854', '#0a1f33'];

          // Exit point: red mark (upper right blue zone)
          this.ax = 0.16;
          this.ay = 0.13;

          // Return point: green mark (left middle blue zone)
          this.bx = -0.18;
          this.by = 0.02;

          // Max depth toward viewer
          this.maxZ = 0.90;

          for (let i = 0; i < count; i++) {
            const dot = document.createElement('a-sphere');
            const radius = 0.002 + Math.random() * 0.004;
            const color  = blues[Math.floor(Math.random() * blues.length)];

            // Spread particles evenly along the arc at start
            const baseT = i / count;

            // Natural density variation: jitter is wider in the middle of stream,
            // tighter at head and tail — gives organic uneven thickness
            const densityEnvelope = Math.sin(baseT * Math.PI);
            const jitterScale = 0.03 + densityEnvelope * 0.07;

            // Additional slow sine modulation along the stream for lumpy natural look
            const lumpiness = 1 + 0.4 * Math.sin(baseT * Math.PI * 5 + Math.random() * 2);

            const jitterX = (Math.random() - 0.5) * jitterScale * lumpiness;
            const jitterY = (Math.random() - 0.5) * jitterScale * 0.6 * lumpiness;

            dot.setAttribute('radius', radius);
            dot.setAttribute('color', color);
            dot.setAttribute('material', 'transparent: true; opacity: 0; shader: flat');
            el.appendChild(dot);

            this.particles.push({
              el: dot,
              t: baseT,      // position along arc 0=head 1=tail
              jitterX,
              jitterY,
              ready: false
            });
          }
        },

        // Compute position on the arc for parameter t (0→1)
        // x, y: lerp from red to green with a slight downward bow
        // z: deep sine arc toward viewer
        getPos: function(t) {
          const ax = this.ax, ay = this.ay;
          const bx = this.bx, by = this.by;

          const x = ax + (bx - ax) * t;
          // Slight downward bow at midpoint (the "falling" feel)
          const y = ay + (by - ay) * t - 0.06 * Math.sin(t * Math.PI);
          const z = this.maxZ * Math.sin(t * Math.PI);

          return { x, y, z };
        },

        tick: function (t, dt) {
          // All particles advance at same speed — full loop every 6 seconds
          const advance = (dt * 0.001) / 6.0;

          this.particles.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.ready = true;
            }

            p.t += advance;
            if (p.t > 1) p.t -= 1;

            const pos = this.getPos(p.t);

            if (pos.z <= 0.001) {
              // Behind the painting — fully hide, no flicker
              p.el.object3D.position.set(0, 0, -2);
              const mesh = p.el.getObject3D('mesh');
              if (mesh && mesh.material) mesh.material.opacity = 0;
              return;
            }

            p.el.object3D.position.set(
              pos.x + p.jitterX,
              pos.y + p.jitterY,
              pos.z
            );

            // Opacity:
            // - fade in as head emerges from painting (t near 0)
            // - fade out as tail returns to painting (t near 1)
            // - tail (high t) is dimmer than head (low t) for comet effect
            const emergeFade = Math.min(p.t / 0.06, 1);
            const returnFade = Math.min((1 - p.t) / 0.06, 1);
            const tailDim    = 1 - Math.pow(p.t, 0.5) * 0.5;
            const opacity    = emergeFade * returnFade * tailDim * 0.92;

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) mesh.material.opacity = opacity;
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity ink-comet></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
