<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('ink-comet', {
        init: function () {
          this.particles = [];
          const el = this.el;
          const count = 800;
          const blues = ['#0d2a45', '#1a3a5c', '#2a5a8c', '#4a7fa5', '#163854', '#0a1f33'];

          // RED mark = where comet HEAD exits the painting
          this.exitX =  0.17;
          this.exitY =  0.12;

          // GREEN mark = where comet TAIL returns to the painting
          this.enterX = -0.20;
          this.enterY = -0.02;

          // How far the comet bows toward the viewer at peak
          this.maxZ = 1.1;

          // What fraction of the loop is visible (rest hidden behind painting)
          // 0.6 = 60% visible, 40% hidden behind painting
          this.arcFraction = 0.60;

          for (let i = 0; i < count; i++) {
            const dot = document.createElement('a-sphere');
            const radius = 0.002 + Math.random() * 0.004;
            const color  = blues[Math.floor(Math.random() * blues.length)];

            // Distribute evenly across the visible arc
            const baseT = (i / count) * this.arcFraction;

            // Organic thickness: wide in middle, tight at ends, with lumps
            const envelope = Math.sin((baseT / this.arcFraction) * Math.PI);
            const lump = 1 + 0.45 * Math.sin((baseT / this.arcFraction) * Math.PI * 4 + Math.random() * 3);
            const spread = (0.025 + envelope * 0.065) * lump;

            const jitterX = (Math.random() - 0.5) * spread;
            const jitterY = (Math.random() - 0.5) * spread * 0.55;

            dot.setAttribute('radius', radius);
            dot.setAttribute('color', color);
            dot.setAttribute('material', 'transparent: true; opacity: 0; shader: flat');
            el.appendChild(dot);

            this.particles.push({
              el: dot,
              t: baseT,
              jitterX,
              jitterY,
              ready: false
            });
          }
        },

        // The arc: exits at red, bows deep toward viewer, returns to green
        // t goes 0→arcFraction for the visible portion
        getPos: function(t) {
          const af = this.arcFraction;
          // normalized 0→1 across visible arc
          const n = t / af;

          // X,Y: interpolate from exit (red) to enter (green)
          // with a slight rightward bow at the peak (viewer-side)
          const x = this.exitX + (this.enterX - this.exitX) * n
                  + 0.12 * Math.sin(n * Math.PI); // bow slightly right at peak

          // Y drops slightly as it comes toward viewer (falling feel)
          const y = this.exitY + (this.enterY - this.exitY) * n
                  - 0.08 * Math.sin(n * Math.PI);

          // Z: deep sine arc, 0 at painting, peak in middle, 0 on return
          const z = this.maxZ * Math.sin(n * Math.PI);

          return { x, y, z };
        },

        tick: function (t, dt) {
          // Full loop every 7 seconds
          const advance = (dt * 0.001) / 7.0;
          const af = this.arcFraction;

          this.particles.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.ready = true;
            }

            p.t += advance;
            if (p.t >= 1.0) p.t -= 1.0;

            // Is this particle in the visible arc (0 → arcFraction)?
            const inArc = p.t <= af;

            if (!inArc) {
              // Hidden behind painting — move far back, fully invisible
              p.el.object3D.position.set(0, 0, -2);
              const mesh = p.el.getObject3D('mesh');
              if (mesh && mesh.material) mesh.material.opacity = 0;
              return;
            }

            const pos = this.getPos(p.t);
            p.el.object3D.position.set(
              pos.x + p.jitterX,
              pos.y + p.jitterY,
              pos.z
            );

            // normalized position along visible arc
            const n = p.t / af;

            // Opacity:
            // - head (n=0) fades in quickly as it exits painting
            // - tail (n=1) fades out as it returns
            // - head brighter than tail (comet effect)
            const headFade = Math.min(n / 0.04, 1);
            const tailFade = Math.min((1 - n) / 0.04, 1);
            const cometDim = 1 - Math.pow(n, 0.4) * 0.55;
            const opacity  = headFade * tailFade * cometDim * 0.92;

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) mesh.material.opacity = opacity;
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity ink-comet></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
