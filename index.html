<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('ink-comet', {
        init: function () {
          this.particles = [];
          const el = this.el;
          const count = 800;
          const blues = ['#0d2a45', '#1a3a5c', '#2a5a8c', '#4a7fa5', '#163854', '#0a1f33'];

          // RED mark: upper right blue zone
          // GREEN mark: left middle blue zone
          // MindAR coords: center=0,0. image width=1 unit. square image so height=1 too.
          // left edge=-0.5, right edge=0.5, top=0.5, bottom=-0.5
          this.exitX  =  0.22;  // red: right side
          this.exitY  =  0.20;  // red: upper area
          this.enterX = -0.22;  // green: left side
          this.enterY =  0.02;  // green: middle

          // How far the comet comes toward viewer at peak
          this.maxZ = 1.2;

          // Fraction of loop that is visible (rest hidden behind painting)
          this.arcFraction = 0.62;

          for (let i = 0; i < count; i++) {
            const dot = document.createElement('a-sphere');
            const radius = 0.002 + Math.random() * 0.004;
            const color  = blues[Math.floor(Math.random() * blues.length)];

            // Position along the full loop 0→1, staggered
            const baseT = (i / count);

            // Organic jitter — wider in middle of stream
            const n = (baseT % this.arcFraction) / this.arcFraction;
            const envelope = Math.sin(n * Math.PI);
            const lump = 1 + 0.5 * Math.sin(n * Math.PI * 4 + Math.random() * Math.PI * 2);
            const spread = (0.02 + envelope * 0.07) * lump;

            const jitterX = (Math.random() - 0.5) * spread;
            const jitterY = (Math.random() - 0.5) * spread * 0.5;

            dot.setAttribute('radius', radius);
            dot.setAttribute('color', color);
            dot.setAttribute('material', 'transparent: true; opacity: 0; shader: flat');
            el.appendChild(dot);

            this.particles.push({
              el: dot,
              t: baseT,
              jitterX,
              jitterY,
              ready: false
            });
          }
        },

        getPos: function(t) {
          const af = this.arcFraction;

          // Is this particle in the visible arc?
          if (t > af) return null;

          // normalized 0→1 across visible arc
          const n = t / af;

          // X: goes from exit (red) to enter (green)
          // Wide outward bow to the right at midpoint → rounder shape
          const bowX = 0.18 * Math.sin(n * Math.PI);
          const x = this.exitX + (this.enterX - this.exitX) * n + bowX;

          // Y: slight downward drift at peak (falling feel)
          const y = this.exitY + (this.enterY - this.exitY) * n
                  - 0.10 * Math.sin(n * Math.PI);

          // Z: sine arc — ZERO exactly at n=0 and n=1 (at the painting surface)
          // peaks at n=0.5
          const z = this.maxZ * Math.sin(n * Math.PI);

          return { x, y, z, n };
        },

        tick: function (t, dt) {
          const advance = (dt * 0.001) / 7.0;
          const af = this.arcFraction;

          this.particles.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.ready = true;
            }

            p.t += advance;
            if (p.t >= 1.0) p.t -= 1.0;

            const pos = this.getPos(p.t);

            if (!pos) {
              // Hidden behind painting
              p.el.object3D.position.set(0, 0, -2);
              const mesh = p.el.getObject3D('mesh');
              if (mesh && mesh.material) mesh.material.opacity = 0;
              return;
            }

            p.el.object3D.position.set(
              pos.x + p.jitterX,
              pos.y + p.jitterY,
              pos.z
            );

            // KEY FIX: opacity driven by Z value, not arc position
            // This means head and tail fade ONLY when actually close to the painting surface
            // They stay fully visible all through space
            const zFadeRange = 0.12; // fade over first/last 12cm of travel
            const zFade = Math.min(pos.z / zFadeRange, 1.0);

            // Comet: head (n=0) bright, tail (n=1) dimmer
            const cometDim = 1 - Math.pow(pos.n, 0.5) * 0.50;

            const opacity = zFade * cometDim * 0.92;

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) mesh.material.opacity = opacity;
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity ink-comet></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
