<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('ink-comet', {
        init: function () {
          this.particles = [];
          const el = this.el;
          const count = 800;
          const blues = ['#0d2a45', '#1a3a5c', '#2a5a8c', '#4a7fa5', '#163854', '#0a1f33'];

          // Exit = RED mark (upper right dense blue)
          this.exitX  =  0.10;
          this.exitY  =  0.28;

          // Enter = GREEN mark (left middle blue)
          this.enterX = -0.22;
          this.enterY =  0.05;

          // Depth toward viewer at peak
          this.maxZ = 1.2;

          // streamLength: what fraction of the full loop the comet occupies
          // MUST be less than 0.5 so head and tail are never both at z=0 simultaneously
          this.streamLength = 0.38;

          for (let i = 0; i < count; i++) {
            const dot = document.createElement('a-sphere');
            const radius = 0.002 + Math.random() * 0.004;
            const color  = blues[Math.floor(Math.random() * blues.length)];

            // Distribute particles across streamLength only
            // t=0 is HEAD (bright, exits painting)
            // t=streamLength is TAIL (dim, follows head)
            const baseT = (i / count) * this.streamLength;

            // Organic thickness
            const n = baseT / this.streamLength;
            const envelope = Math.sin(n * Math.PI);
            const lump = 1 + 0.45 * Math.sin(n * Math.PI * 5 + Math.random() * Math.PI * 2);
            const spread = (0.018 + envelope * 0.065) * lump;

            const jitterX = (Math.random() - 0.5) * spread;
            const jitterY = (Math.random() - 0.5) * spread * 0.5;

            dot.setAttribute('radius', radius);
            dot.setAttribute('color', color);
            dot.setAttribute('material', 'transparent: true; opacity: 0; shader: flat');
            el.appendChild(dot);

            this.particles.push({
              el: dot,
              // offset along loop: stagger start so stream is mid-journey
              loopT: baseT + 0.05,
              baseN: n,  // 0=head, 1=tail (fixed per particle)
              jitterX,
              jitterY,
              ready: false
            });
          }
        },

        // Full loop: 
        // 0.0 → 0.5: front arc (visible, from exit over viewer and back to enter)
        // 0.5 → 1.0: back arc (hidden behind painting)
        // getPos returns null if particle is behind painting
        getPos: function(loopT) {
          // normalize to 0→1
          const t = loopT % 1.0;

          // Front half of loop = visible (0 to 0.5)
          if (t > 0.5) return null;

          // n goes 0→1 across the front arc
          const n = t / 0.5;

          // X: from exit to enter, with outward bow (rounder shape)
          const midX = (this.exitX + this.enterX) / 2;
          const bowX = (midX - 0) * 0.0 + 0.08 * Math.sin(n * Math.PI);
          const x = this.exitX + (this.enterX - this.exitX) * n + bowX;

          // Y: exit to enter, with downward arc at peak
          const y = this.exitY + (this.enterY - this.exitY) * n
                  - 0.12 * Math.sin(n * Math.PI);

          // Z: peaks at midpoint (n=0.5), zero at endpoints
          const z = this.maxZ * Math.sin(n * Math.PI);

          return { x, y, z, n };
        },

        tick: function (t, dt) {
          // Full loop every 7 seconds
          const advance = (dt * 0.001) / 7.0;

          this.particles.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.ready = true;
            }

            p.loopT += advance;
            if (p.loopT >= 1.0) p.loopT -= 1.0;

            const pos = this.getPos(p.loopT);

            if (!pos) {
              p.el.object3D.position.set(0, 0, -2);
              const mesh = p.el.getObject3D('mesh');
              if (mesh && mesh.material) mesh.material.opacity = 0;
              return;
            }

            p.el.object3D.position.set(
              pos.x + p.jitterX,
              pos.y + p.jitterY,
              pos.z
            );

            // Opacity based purely on Z — fades only near painting surface
            const zFade = Math.min(pos.z / 0.10, 1.0);

            // Comet: head bright, tail fades — based on particle's fixed position in stream
            const cometDim = 1 - Math.pow(p.baseN, 0.6) * 0.60;

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) {
              mesh.material.opacity = zFade * cometDim * 0.92;
            }
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity ink-comet></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
