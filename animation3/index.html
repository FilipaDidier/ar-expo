<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('branch-growth', {
        init: function () {
          this.segments = [];
          this.time = 0;
          const el = this.el;

          this.buildDuration = 5.0;
          this.holdDuration  = 3.0;
          this.fadeDuration  = 3.0;
          this.pauseDuration = 1.5;
          this.cycleDuration = this.buildDuration + this.holdDuration
                             + this.fadeDuration  + this.pauseDuration;

          // Light blue-grey — matches the pale washed-out color of the painting
          const blues = ['#7aacc8', '#8ab8d0', '#6a9ab8', '#5a8aaa', '#90b8cc'];

          // Frame inner radius ≈ 0.26, outer ≈ 0.42
          // Branches stay at z=0 until r>0.26, then rise
          const frameInner = 0.26;
          const cx = 0.0, cy = 0.05; // painting center

          function getZ(x, y) {
            const r = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
            if (r <= frameInner) return 0.01;
            // Rise progressively after frame inner edge
            return Math.min((r - frameInner) / 0.20 * 0.22, 0.22);
          }

          function bezier(A, B, C, t) {
            const u = 1 - t;
            return {
              x: u*u*A.x + 2*u*t*B.x + t*t*C.x,
              y: u*u*A.y + 2*u*t*B.y + t*t*C.y,
            };
          }

          // Branches: start from painted tips, end beyond frame
          const branches = [
            { start:{x:-0.06,y:0.18}, ctrl:{x:-0.16,y:0.34}, end:{x:-0.24,y:0.50},
              subs:[
                {tFork:0.50, ctrl:{x:-0.28,y:0.30}, end:{x:-0.40,y:0.28}},
                {tFork:0.72, ctrl:{x:-0.16,y:0.46}, end:{x:-0.14,y:0.58}},
              ]},
            { start:{x:0.02,y:0.20}, ctrl:{x:0.02,y:0.38}, end:{x:0.02,y:0.56},
              subs:[
                {tFork:0.45, ctrl:{x:-0.10,y:0.36}, end:{x:-0.18,y:0.46}},
                {tFork:0.68, ctrl:{x: 0.12,y:0.38}, end:{x: 0.20,y:0.50}},
              ]},
            { start:{x:0.12,y:0.16}, ctrl:{x:0.24,y:0.32}, end:{x:0.34,y:0.48},
              subs:[
                {tFork:0.48, ctrl:{x:0.30,y:0.22}, end:{x:0.44,y:0.20}},
                {tFork:0.70, ctrl:{x:0.26,y:0.42}, end:{x:0.34,y:0.54}},
              ]},
            { start:{x:0.16,y:0.02}, ctrl:{x:0.32,y:0.02}, end:{x:0.50,y:0.02},
              subs:[
                {tFork:0.44, ctrl:{x:0.28,y:0.14}, end:{x:0.36,y:0.24}},
                {tFork:0.68, ctrl:{x:0.36,y:-0.08}, end:{x:0.48,y:-0.16}},
              ]},
            { start:{x:0.10,y:-0.10}, ctrl:{x:0.22,y:-0.24}, end:{x:0.30,y:-0.40},
              subs:[
                {tFork:0.46, ctrl:{x:0.30,y:-0.14}, end:{x:0.44,y:-0.12}},
                {tFork:0.68, ctrl:{x:0.20,y:-0.34}, end:{x:0.16,y:-0.48}},
              ]},
            { start:{x:-0.12,y:0.02}, ctrl:{x:-0.28,y:0.02}, end:{x:-0.48,y:0.02},
              subs:[
                {tFork:0.44, ctrl:{x:-0.24,y:0.16}, end:{x:-0.34,y:0.24}},
                {tFork:0.66, ctrl:{x:-0.30,y:-0.10}, end:{x:-0.44,y:-0.18}},
              ]},
          ];

          const stepsPerBranch = 60;
          const stepsPerSub    = 30;

          const buildSegments = (pts, tOffset, tScale) => {
            for (let i = 0; i < pts.length - 1; i++) {
              const A = pts[i];
              const B = pts[i + 1];

              const mx = (A.x + B.x) / 2;
              const my = (A.y + B.y) / 2;
              const mz = (A.z + B.z) / 2;

              const dx = B.x - A.x;
              const dy = B.y - A.y;
              const dz = B.z - A.z;
              const length = Math.sqrt(dx*dx + dy*dy + dz*dz);

              if (length < 0.0001) return;

              // Cylinder between A and B
              const cyl = document.createElement('a-cylinder');
              const radius = Math.max(0.003 - (tOffset + (i/pts.length)*tScale) * 0.002, 0.001);
              const color = blues[Math.floor(Math.random() * blues.length)];

              cyl.setAttribute('radius', radius);
              cyl.setAttribute('height', length);
              cyl.setAttribute('color', color);
              cyl.setAttribute('material', 'transparent: true; opacity: 0; shader: flat; side: double');
              cyl.setAttribute('position', `${mx} ${my} ${mz}`);

              // Orient cylinder along direction vector
              // A-Frame cylinders are Y-up by default
              const dirX = dx / length;
              const dirY = dy / length;
              const dirZ = dz / length;

              // Rotation to align Y-axis with direction
              const up = new THREE.Vector3(0, 1, 0);
              const dir = new THREE.Vector3(dirX, dirY, dirZ);
              const quaternion = new THREE.Quaternion();
              quaternion.setFromUnitVectors(up, dir);
              const euler = new THREE.Euler().setFromQuaternion(quaternion);

              cyl.setAttribute('rotation', {
                x: THREE.MathUtils.radToDeg(euler.x),
                y: THREE.MathUtils.radToDeg(euler.y),
                z: THREE.MathUtils.radToDeg(euler.z)
              });

              el.appendChild(cyl);

              // t: growth order 0→1
              const segT = tOffset + (i / pts.length) * tScale;

              this.segments.push({ el: cyl, t: segT, ready: false });
            }
          };

          branches.forEach(branch => {
            // Build main branch point array
            const pts = [];
            for (let i = 0; i <= stepsPerBranch; i++) {
              const t = i / stepsPerBranch;
              const p = bezier(branch.start, branch.ctrl, branch.end, t);
              pts.push({ x: p.x, y: p.y, z: getZ(p.x, p.y) });
            }
            buildSegments(pts, 0, 1.0);

            // Sub-branches
            branch.subs.forEach(sub => {
              const forkXY = bezier(branch.start, branch.ctrl, branch.end, sub.tFork);
              const forkPt = { x: forkXY.x, y: forkXY.y, z: getZ(forkXY.x, forkXY.y) };

              const subPts = [forkPt];
              for (let i = 1; i <= stepsPerSub; i++) {
                const t = i / stepsPerSub;
                const p = bezier(forkPt, sub.ctrl, sub.end, t);
                subPts.push({ x: p.x, y: p.y, z: getZ(p.x, p.y) });
              }
              // Sub starts growing when fork point is reached
              buildSegments(subPts, sub.tFork, 1 - sub.tFork);
            });
          });
        },

        tick: function(t, dt) {
          this.time += dt * 0.001;
          const cycleT = this.time % this.cycleDuration;

          const buildEnd = this.buildDuration;
          const holdEnd  = buildEnd + this.holdDuration;
          const fadeEnd  = holdEnd  + this.fadeDuration;

          this.segments.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.ready = true;
            }

            let opacity = 0;

            if (cycleT < buildEnd) {
              const front = cycleT / buildEnd;
              if (p.t <= front) {
                opacity = Math.min((front - p.t) / 0.06, 1.0) * 0.60;
              }
            } else if (cycleT < holdEnd) {
              opacity = 0.60;
            } else if (cycleT < fadeEnd) {
              const dissolveFront = (cycleT - holdEnd) / this.fadeDuration;
              const dissolvePos = 1 - p.t;
              if (dissolvePos <= dissolveFront) {
                opacity = (1 - Math.min((dissolveFront - dissolvePos) / 0.06, 1.0)) * 0.60;
              } else {
                opacity = 0.60;
              }
            }

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) mesh.material.opacity = opacity;
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity branch-growth></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
