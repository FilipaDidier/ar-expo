<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('branch-growth', {
        init: function () {
          this.particles = [];
          this.time = 0;
          const el = this.el;

          // Timings
          this.buildDuration = 5.0;
          this.holdDuration  = 3.0;
          this.fadeDuration  = 3.0;
          this.pauseDuration = 1.5;
          this.cycleDuration = this.buildDuration + this.holdDuration
                             + this.fadeDuration  + this.pauseDuration;

          // Blue-indigo palette matching the painting
          const blues = [
            '#0d2a45', '#1a3a5c', '#2a5a8c',
            '#163854', '#1e4d6b', '#4a7fa5'
          ];

          // Each main branch: start point (on painted tip) + control point + end point
          // End points are beyond the frame (radius > 0.42) and rise in Z
          // Painting center approx (0.0, 0.05)
          const branches = [
            // Top-left branch
            {
              start: { x: -0.08, y: 0.20, z: 0.0 },
              ctrl:  { x: -0.18, y: 0.32, z: 0.08 },
              end:   { x: -0.28, y: 0.48, z: 0.18 },
              subs: [
                { tFork: 0.45, ctrl: { x: -0.24, y: 0.30, z: 0.08 }, end: { x: -0.34, y: 0.28, z: 0.14 } },
                { tFork: 0.70, ctrl: { x: -0.20, y: 0.44, z: 0.12 }, end: { x: -0.18, y: 0.54, z: 0.16 } },
              ]
            },
            // Top-center branch
            {
              start: { x: 0.02, y: 0.22, z: 0.0 },
              ctrl:  { x: 0.04, y: 0.36, z: 0.08 },
              end:   { x: 0.05, y: 0.54, z: 0.20 },
              subs: [
                { tFork: 0.40, ctrl: { x: -0.06, y: 0.38, z: 0.10 }, end: { x: -0.14, y: 0.44, z: 0.15 } },
                { tFork: 0.65, ctrl: { x:  0.14, y: 0.42, z: 0.10 }, end: { x:  0.20, y: 0.50, z: 0.16 } },
              ]
            },
            // Top-right branch
            {
              start: { x: 0.13, y: 0.18, z: 0.0 },
              ctrl:  { x: 0.24, y: 0.30, z: 0.08 },
              end:   { x: 0.34, y: 0.44, z: 0.18 },
              subs: [
                { tFork: 0.50, ctrl: { x: 0.30, y: 0.24, z: 0.08 }, end: { x: 0.42, y: 0.22, z: 0.14 } },
                { tFork: 0.72, ctrl: { x: 0.28, y: 0.40, z: 0.12 }, end: { x: 0.36, y: 0.52, z: 0.16 } },
              ]
            },
            // Right branch
            {
              start: { x: 0.16, y: 0.04, z: 0.0 },
              ctrl:  { x: 0.30, y: 0.06, z: 0.08 },
              end:   { x: 0.48, y: 0.08, z: 0.20 },
              subs: [
                { tFork: 0.40, ctrl: { x: 0.28, y: 0.14, z: 0.08 }, end: { x: 0.38, y: 0.22, z: 0.14 } },
                { tFork: 0.68, ctrl: { x: 0.38, y:-0.04, z: 0.10 }, end: { x: 0.50, y:-0.12, z: 0.15 } },
              ]
            },
            // Bottom-right branch
            {
              start: { x: 0.10, y: -0.08, z: 0.0 },
              ctrl:  { x: 0.22, y: -0.18, z: 0.08 },
              end:   { x: 0.32, y: -0.34, z: 0.18 },
              subs: [
                { tFork: 0.45, ctrl: { x: 0.30, y:-0.12, z: 0.08 }, end: { x: 0.42, y:-0.10, z: 0.13 } },
                { tFork: 0.70, ctrl: { x: 0.22, y:-0.30, z: 0.10 }, end: { x: 0.18, y:-0.42, z: 0.16 } },
              ]
            },
            // Left branch
            {
              start: { x: -0.14, y: 0.02, z: 0.0 },
              ctrl:  { x: -0.28, y: 0.04, z: 0.08 },
              end:   { x: -0.46, y: 0.06, z: 0.20 },
              subs: [
                { tFork: 0.42, ctrl: { x:-0.26, y: 0.14, z: 0.08 }, end: { x:-0.36, y: 0.20, z: 0.14 } },
                { tFork: 0.66, ctrl: { x:-0.34, y:-0.06, z: 0.10 }, end: { x:-0.46, y:-0.14, z: 0.15 } },
              ]
            },
          ];

          // Bezier helper
          function bezier(A, B, C, t) {
            const u = 1 - t;
            return {
              x: u*u*A.x + 2*u*t*B.x + t*t*C.x,
              y: u*u*A.y + 2*u*t*B.y + t*t*C.y,
              z: u*u*A.z + 2*u*t*B.z + t*t*C.z,
            };
          }

          const particlesPerBranch = 120;
          const particlesPerSub    = 55;

          branches.forEach(branch => {
            // Main branch particles
            for (let i = 0; i < particlesPerBranch; i++) {
              const dot = document.createElement('a-sphere');
              const t = i / particlesPerBranch;
              const pos = bezier(branch.start, branch.ctrl, branch.end, t);

              const jx = (Math.random() - 0.5) * 0.012;
              const jy = (Math.random() - 0.5) * 0.012;
              const jz = (Math.random() - 0.5) * 0.008;

              // Taper: thick at base, thin at tip
              const taper = 1 - t * 0.65;
              const radius = (0.004 + Math.random() * 0.005) * taper;
              const color = blues[Math.floor(Math.random() * blues.length)];

              dot.setAttribute('radius', radius);
              dot.setAttribute('color', color);
              dot.setAttribute('material', 'transparent: true; opacity: 0; shader: flat');
              el.appendChild(dot);

              this.particles.push({
                el: dot,
                x: pos.x + jx,
                y: pos.y + jy,
                z: pos.z + jz,
                t,           // growth order: t=0 appears first
                ready: false
              });
            }

            // Sub-branches
            branch.subs.forEach(sub => {
              const forkPos = bezier(branch.start, branch.ctrl, branch.end, sub.tFork);

              for (let i = 0; i < particlesPerSub; i++) {
                const dot = document.createElement('a-sphere');
                const t = i / particlesPerSub;
                const pos = bezier(forkPos, sub.ctrl, sub.end, t);

                const jx = (Math.random() - 0.5) * 0.010;
                const jy = (Math.random() - 0.5) * 0.010;
                const jz = (Math.random() - 0.5) * 0.007;

                const taper = 1 - t * 0.75;
                const radius = (0.003 + Math.random() * 0.004) * taper;
                const color = blues[Math.floor(Math.random() * blues.length)];

                dot.setAttribute('radius', radius);
                dot.setAttribute('color', color);
                dot.setAttribute('material', 'transparent: true; opacity: 0; shader: flat');
                el.appendChild(dot);

                // Sub-branch growth starts when fork point is reached
                // t=0 on sub = sub.tFork on main timeline
                const globalT = sub.tFork + t * (1 - sub.tFork);

                this.particles.push({
                  el: dot,
                  x: pos.x + jx,
                  y: pos.y + jy,
                  z: pos.z + jz,
                  t: globalT,
                  ready: false
                });
              }
            });
          });

          // Set all positions immediately (fixed, no tick movement)
          // Tick only controls opacity
        },

        tick: function(t, dt) {
          this.time += dt * 0.001;
          const cycleT = this.time % this.cycleDuration;

          const buildEnd = this.buildDuration;
          const holdEnd  = buildEnd + this.holdDuration;
          const fadeEnd  = holdEnd  + this.fadeDuration;

          this.particles.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.el.object3D.position.set(p.x, p.y, p.z);
              p.ready = true;
            }

            let opacity = 0;

            if (cycleT < buildEnd) {
              const front = cycleT / buildEnd;
              if (p.t <= front) {
                const fadeIn = Math.min((front - p.t) / 0.06, 1.0);
                opacity = fadeIn * 0.88;
              }

            } else if (cycleT < holdEnd) {
              opacity = 0.88;

            } else if (cycleT < fadeEnd) {
              const dissolveFront = (cycleT - holdEnd) / this.fadeDuration;
              const dissolvePos = 1 - p.t;
              if (dissolvePos <= dissolveFront) {
                const fadeOut = Math.min((dissolveFront - dissolvePos) / 0.06, 1.0);
                opacity = (1 - fadeOut) * 0.88;
              } else {
                opacity = 0.88;
              }
            }

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) mesh.material.opacity = opacity;
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity branch-growth></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
