<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <script>
      AFRAME.registerComponent('branch-growth', {
        init: function () {
          this.segments = [];
          this.time = 0;
          const el = this.el;

          this.buildDuration = 5.0;
          this.holdDuration  = 3.0;
          this.fadeDuration  = 3.0;
          this.pauseDuration = 1.5;
          this.cycleDuration = this.buildDuration + this.holdDuration
                             + this.fadeDuration  + this.pauseDuration;

          const blues = ['#7aacc8', '#8ab8d0', '#6a9ab8', '#5a8aaa', '#90b8cc'];

          const frameInner = 0.26;
          const cx = 0.02, cy = 0.08;

          function getZ(x, y) {
            const r = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
            if (r <= frameInner) return 0.005;
            return Math.min((r - frameInner) / 0.18 * 0.22, 0.22);
          }

          function bezier(A, B, C, t) {
            const u = 1 - t;
            return {
              x: u*u*A.x + 2*u*t*B.x + t*t*C.x,
              y: u*u*A.y + 2*u*t*B.y + t*t*C.y,
            };
          }

          // Each branch: starts at red dot, ctrl bends outward, end beyond frame
          // Direction = away from center (cx, cy)
          const branches = [
            // 1. far left tip → continues left-down
            { start:{x:-0.12,y:0.16}, ctrl:{x:-0.22,y:0.10}, end:{x:-0.36,y:0.04},
              subs:[{tFork:0.55, ctrl:{x:-0.24,y:0.18}, end:{x:-0.34,y:0.26}}]},

            // 2. left cluster upper → continues upper-left
            { start:{x:-0.08,y:0.22}, ctrl:{x:-0.18,y:0.32}, end:{x:-0.28,y:0.46},
              subs:[{tFork:0.50, ctrl:{x:-0.22,y:0.24}, end:{x:-0.32,y:0.22}}]},

            // 3. left cluster lower → continues left
            { start:{x:-0.04,y:0.24}, ctrl:{x:-0.10,y:0.36}, end:{x:-0.14,y:0.52},
              subs:[{tFork:0.55, ctrl:{x:-0.18,y:0.32}, end:{x:-0.28,y:0.36}}]},

            // 4. center-left upper → continues up-left
            { start:{x:0.00,y:0.26}, ctrl:{x:-0.04,y:0.38}, end:{x:-0.06,y:0.54},
              subs:[{tFork:0.50, ctrl:{x:0.06,y:0.40}, end:{x:0.10,y:0.52}}]},

            // 5. center top → continues straight up
            { start:{x:0.04,y:0.28}, ctrl:{x:0.04,y:0.42}, end:{x:0.04,y:0.58},
              subs:[
                {tFork:0.45, ctrl:{x:-0.06,y:0.42}, end:{x:-0.12,y:0.52}},
                {tFork:0.65, ctrl:{x: 0.12,y:0.44}, end:{x: 0.18,y:0.54}},
              ]},

            // 6. center-right upper → continues up-right
            { start:{x:0.08,y:0.24}, ctrl:{x:0.16,y:0.36}, end:{x:0.24,y:0.50},
              subs:[{tFork:0.52, ctrl:{x:0.20,y:0.28}, end:{x:0.32,y:0.26}}]},

            // 7. right cluster upper → continues upper-right
            { start:{x:0.13,y:0.22}, ctrl:{x:0.24,y:0.32}, end:{x:0.36,y:0.44},
              subs:[{tFork:0.50, ctrl:{x:0.28,y:0.20}, end:{x:0.42,y:0.18}}]},

            // 8. right cluster mid → continues right
            { start:{x:0.16,y:0.18}, ctrl:{x:0.28,y:0.20}, end:{x:0.46,y:0.22},
              subs:[{tFork:0.55, ctrl:{x:0.30,y:0.10}, end:{x:0.44,y:0.08}}]},

            // 9. right branch upper → continues right
            { start:{x:0.20,y:0.12}, ctrl:{x:0.32,y:0.12}, end:{x:0.50,y:0.12},
              subs:[{tFork:0.50, ctrl:{x:0.32,y:0.20}, end:{x:0.44,y:0.28}}]},

            // 10. right branch mid → continues right-down
            { start:{x:0.20,y:0.06}, ctrl:{x:0.32,y:0.04}, end:{x:0.50,y:0.02},
              subs:[{tFork:0.55, ctrl:{x:0.32,y:-0.04}, end:{x:0.44,y:-0.10}}]},

            // 11. right branch lower → continues right-down
            { start:{x:0.18,y:0.02}, ctrl:{x:0.30,y:-0.04}, end:{x:0.46,y:-0.10},
              subs:[{tFork:0.50, ctrl:{x:0.28,y:0.08}, end:{x:0.38,y:0.14}}]},

            // 12. bottom-right tip → continues down-right
            { start:{x:0.14,y:-0.02}, ctrl:{x:0.24,y:-0.10}, end:{x:0.36,y:-0.22},
              subs:[{tFork:0.55, ctrl:{x:0.26,y:-0.04}, end:{x:0.38,y:0.02}}]},
          ];

          const stepsPerBranch = 50;
          const stepsPerSub    = 28;

          const buildSegments = (pts, tStart, tScale) => {
            for (let i = 0; i < pts.length - 1; i++) {
              const A = pts[i], B = pts[i+1];
              const mx = (A.x+B.x)/2, my = (A.y+B.y)/2, mz = (A.z+B.z)/2;
              const dx = B.x-A.x, dy = B.y-A.y, dz = B.z-A.z;
              const length = Math.sqrt(dx*dx+dy*dy+dz*dz);
              if (length < 0.0001) continue;

              const cyl = document.createElement('a-cylinder');
              const segT = tStart + (i / pts.length) * tScale;
              const taper = Math.max(1 - segT * 0.7, 0.2);
              const radius = 0.004 * taper;
              const color = blues[Math.floor(Math.random() * blues.length)];

              cyl.setAttribute('radius', radius);
              cyl.setAttribute('height', length);
              cyl.setAttribute('color', color);
              cyl.setAttribute('segments-height', 1);
              cyl.setAttribute('segments-radial', 5);
              cyl.setAttribute('material', 'transparent: true; opacity: 0; shader: flat; side: double');
              cyl.setAttribute('position', `${mx} ${my} ${mz}`);

              const up = new THREE.Vector3(0,1,0);
              const dir = new THREE.Vector3(dx/length, dy/length, dz/length);
              const q = new THREE.Quaternion().setFromUnitVectors(up, dir);
              const e = new THREE.Euler().setFromQuaternion(q);
              cyl.setAttribute('rotation', {
                x: THREE.MathUtils.radToDeg(e.x),
                y: THREE.MathUtils.radToDeg(e.y),
                z: THREE.MathUtils.radToDeg(e.z)
              });

              el.appendChild(cyl);
              this.segments.push({ el: cyl, t: segT, ready: false });
            }
          };

          branches.forEach(branch => {
            const pts = [];
            for (let i = 0; i <= stepsPerBranch; i++) {
              const t = i / stepsPerBranch;
              const p = bezier(branch.start, branch.ctrl, branch.end, t);
              pts.push({ x: p.x, y: p.y, z: getZ(p.x, p.y) });
            }
            buildSegments(pts, 0, 1.0);

            branch.subs.forEach(sub => {
              const fXY = bezier(branch.start, branch.ctrl, branch.end, sub.tFork);
              const fPt = { x: fXY.x, y: fXY.y, z: getZ(fXY.x, fXY.y) };
              const subPts = [fPt];
              for (let i = 1; i <= stepsPerSub; i++) {
                const t = i / stepsPerSub;
                const p = bezier(fPt, sub.ctrl, sub.end, t);
                subPts.push({ x: p.x, y: p.y, z: getZ(p.x, p.y) });
              }
              buildSegments(subPts, sub.tFork, 1 - sub.tFork);
            });
          });
        },

        tick: function(t, dt) {
          this.time += dt * 0.001;
          const cycleT = this.time % this.cycleDuration;
          const buildEnd = this.buildDuration;
          const holdEnd  = buildEnd + this.holdDuration;
          const fadeEnd  = holdEnd  + this.fadeDuration;

          this.segments.forEach(p => {
            if (!p.ready) {
              if (!p.el.object3D) return;
              p.ready = true;
            }

            let opacity = 0;
            if (cycleT < buildEnd) {
              const front = cycleT / buildEnd;
              if (p.t <= front) opacity = Math.min((front - p.t) / 0.06, 1.0) * 0.55;
            } else if (cycleT < holdEnd) {
              opacity = 0.55;
            } else if (cycleT < fadeEnd) {
              const dFront = (cycleT - holdEnd) / this.fadeDuration;
              const dPos = 1 - p.t;
              if (dPos <= dFront) opacity = (1 - Math.min((dFront - dPos) / 0.06, 1.0)) * 0.55;
              else opacity = 0.55;
            }

            const mesh = p.el.getObject3D('mesh');
            if (mesh && mesh.material) mesh.material.opacity = opacity;
          });
        }
      });
    </script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity branch-growth></a-entity>
      </a-entity>

    </a-scene>
  </body>
</html>
